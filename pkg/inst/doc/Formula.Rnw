\documentclass[codesnippet,nojss]{jss}
\usepackage{thumbpdf}
%% need no \usepackage{Sweave}

%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}

\author{Achim Zeileis\\WU Wirtschaftsuniversit\"at Wien
   \And Yves Croissant\\Universit\'e Lumi\`ere Lyon 2}
\Plainauthor{Achim Zeileis, Yves Croissant}

\title{Extended Model Formulas in \proglang{R}: Multiple Parts and Multiple Responses}
\Plaintitle{Extended Model Formulas in R: Multiple Parts and Multiple Responses}
\Shorttitle{Extended Model Formulas in \proglang{R}}

\Keywords{formula processing, model frame, model matrix, \proglang{R}}
\Plainkeywords{formula processing, model frame, model matrix, R}

\Abstract{ 
  extended formula process
  
  multiple parts (e.g., regressors and instruments)
  
  multiple responses (of different types)
}

\Address{
  Achim Zeileis\\
  Department of Statistics and Mathematics\\
  WU Wirtschaftsuniversit\"at Wien\\
  Augasse 2--6\\
  A-1090 Wien, Austria\\
  E-mail: \email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://statmath.wu-wien.ac.at/~zeileis/}

  Yves Croissant\\
  LET-ISH\\
  Avenue Berthelot\\
  F-69363 Lyon cedex 07, France\\
  E-mail: \email{yves.croissant@let.ish-lyon.cnrs.fr}\\
}

\begin{document}

\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}
%\VignetteIndexEntry{Extended Model Formulas in R: Multiple Parts and Multiple Responses}
%\VignetteDepends{stats}
%\VignetteKeywords{formula processing, model frame, model matrix, R}
%\VignettePackage{Formula}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
library("Formula")
@

\section{Introduction} \label{sec:intro}

Since publication of the seminal ``white book'' \citep{Formula:Chambers+Hastie:1992}
the standard approach for fitting statistical models in the \proglang{S}
language is to apply some model-fitting function (such as \fct{lm} or \fct{glm})
to a \class{formula} description of the variables involved in the model and typically
stored in a \class{data.frame}. The semantics of formula processing
are based on the ideas of the \cite{Formula:Wilkinson+Rogers:1973} notation which in turn
was targeted at specification of analysis of variance models. Despite this emphasis
on specification of terms in models with linear predictors, formula notation
has always been used much more generally, e.g., for specifying variables in classification
and regression trees, margins in contingency tables, or variables in graphical displays.

However, there are certain limitations to the formula language in \proglang{S} that
can be rather inconvenient in certain applications: (1)~The formula notation can
just be used on the right-hand side (RHS) of a formula (on the right of the \code{~})
while it has it's original arithmetic meaning on the left-hand side (LHS). This makes it
difficult to specify multiple responses, especially if these are not numeric (e.g., factors).
This feature would be useful for specifying multivariate outcomes of mixed type
in independence tests \citep[see e.g.,][]{Formula:Hothorn+Hornik+VanDeWiel:2006,Formula:Hothorn+Hornik+VanDeWiel:2008}.
%% \cite{Formula:Therneau+Lumley:2009}
(2)~There is no simple construct in standard formula notation that allows to
separate several groups of variables from which separate model matrices can be
derived. This task occurs in many types of models, e.g., when processing
regressors and instruments in instrumental variable regressions
\citep[see e.g.,][]{Formula:Croissant+Millo:2008},
variables in two-part models such as hurdle models or zero-inflated regressions
\citep[see e.g.,][]{Formula:Zeileis+Kleiber+Jackman:2008},
alternative-specific and individual-specific variables in choice models
\citep[see e.g.,][]{Formula:Croissant:2008}, or
modeling variables and partitioning variables in model-based recursive partitioning techniques
\citep[see e.g.,][]{Formula:Zeileis+Hothorn+Hornik:2008}.

As we repeatedly needed these additional features in our own packages
and addressed this in the past by various different solutions, it seemed natural
to provide a more general unified approach that could also be employed easily
by other package developers. In the remainder of this paper we discuss
how multiple responses and multiple parts (both on the LHS and RHS) are enabled
in the \pkg{Formula} package written in the \proglang{R} system for statistical
computing \cite{Formula:R:2009} and available from the Comprehensive \proglang{R}
Archive Network at \url{http://CRAN.R-project.org/package=Formula}. The \class{Formula}
class just adds a thin additional layer to \class{formula} objects which is based
on a single additional operator, namely \code{|}, that can be used separate different
parts (or groups) of variables. \pkg{Formula} essentially just handles the different
formula parts and leverages the existing methods for \class{formula} objects for all
remaining operations. In Section~\ref{sec:motivation} we show two small motivating
examples that convey the main ideas implemented in the package and how easily they
can be employed. The details of the \class{Formula} class and its associated methods
are discussed in Section~\ref{sec:implementation}. A short summary in Section~\ref{sec:summary}
concludes the paper.


\section{Motivating examples} \label{sec:motivation}

To illustrate the basic ideas of the \pkg{Formula} package, we first generate a small
artificial data set (with both numeric and categorical variables) and subsequently
illustrate its usage with a multi-part \class{Formula} and a multi-response
\class{Formula}, respectively. 

<<example-data>>=
set.seed(1090)
dat <- as.data.frame(matrix(round(runif(21), digits = 2), ncol = 7))
colnames(dat) <- c("y1", "y2", "y3", "x1", "x2", "x3", "x4")
for(i in c(2, 6:7)) dat[[i]] <- factor(dat[[i]] < 0.5,
  labels = c("a", "b"))
dat
@


\subsection{Multiple parts}

We start out with a simple formula \verb/log(y1) ~ x1 + x2 | I(x1^2)/ which
has a single response \code{log(y1)} on the LHS and two parts on the RHS, separated
by \code{|}. The first part contains \code{x1} and \code{x2}, the second contains
\verb/I(x1^2)/, i.e., the squared values of \code{x1}. The initial \class{formula}
can be transformed to a \class{Formula} using the constructor function \fct{Formula}:
%
<<multi-part1>>=
F1 <- Formula(log(y1) ~ x1 + x2 | I(x1^2))
length(F1)
@
%
The \fct{length} method indicates that there is one part on the LHS and two parts
on the RHS. The first step of processing data using a formula is typically the
construction of a so-called model frame containing only the variables required
by the formula. As usual, this can be obtained with the \fct{model.frame} method.
%
<<multi-part2>>=
mf1 <- model.frame(F1, data = dat)
mf1
@
%
As this model just has a single response (as in the base \class{formula} objects),
the extractor function \fct{model.response} can be employed:
%
<<multi-part3>>=
model.response(mf1)
@
%
For constructing separate model matrices for the two parts on the RHS, the
\fct{model.matrix} can be employed and additionally specifying the argument
\code{rhs}:
%
<<multi-part4>>=
model.matrix(F1, data = mf1, rhs = 1)
model.matrix(F1, data = mf1, rhs = 2)
@


\subsection{Multiple responses}

To accomodate multiple responses, all formula operators can be employed
on the LHS in \class{Formula} objects (whereas they would have their original
arithmetic meaning in \class{formula} objects). This also includes the 
new \code{|} operator for separating different parts. Thus, one could
specify a two-part response via \code{y1 | y2 ~ x3} or a single part
with two variables via \code{y1 + y2 ~ x3}. We do the latter in the
following illustration.
%
<<multi-response1>>=
F2 <- Formula(y1 + y2 ~ x3)
length(F2)
@
%
As usual, the model frame can be derived by
%
<<multi-response2>>=
mf2 <- model.frame(F2, data = dat)
mf2
@
%
However, there is an important difference to the model frame \code{mf1}
derived in the previous example. As the (non-generic) \fct{model.response}
function would only be able to extract a single response column from a model frame,
multi-response model frames in \pkg{Formula} are implemented to have no response
at all in the \fct{model.response} sense:
%
<<multi-response3>>=
model.response(mf2)
@
%
Despite this, LHS and RHS variables can be easily extracted by employing
the \fct{model.frame} method in which the requested subsets of LHS and RHS parts
can be supplied via \code{lhs} and \code{rhs}, respectively. Thus, to omit
all RHS parts \code{rhs} is set to \code{0} while all LHS parts are
included (by default):
%
<<multi-response4>>=
Model.Response(F2, data = mf2)
@
%
More details on the \code{lhs} and \code{rhs} arguments will be discussed
in the next section. Finally, the model matrix can be derived as usual:
%
<<multi-response5>>=
model.matrix(F2, data = mf2)
@

<<>>=
Model.Response(F1, data = mf1)
@

\section{Implementation} \label{sec:implementation}



\subsubsection*{Constructing \class{Formula} objects}

\code{+}, \code{-}, \code{*}, \code{/}, \code{:}, \verb+%in%+, \verb+^+

<<details1>>=
F3 <- Formula(y1 + y2 | log(y3) ~ x1 + I(x2^2) | 0 + log(x1) | x3 / x4)
F3
length(F3)
attr(F3, "lhs")
attr(F3, "rhs")
@

\subsubsection*{Extracting \class{formula} and \class{terms} objects}

<<formula-method>>=
formula(F3)
formula(F3, lhs = 2, rhs = -2)
formula(F3, lhs = c(TRUE, FALSE), rhs = 0)
@

<<terms-method1, eval=FALSE>>=
terms(F3)
@

<<terms-method>>=
formula(terms(F3))
formula(terms(F3, lhs = 2, rhs = -2))
formula(terms(F3, lhs = c(TRUE, FALSE), rhs = 0))
@

\subsubsection*{Computing model frames, matrices, and responses}

<<model.frame-method>>=
mf3 <- model.frame(F3, data = dat, subset = y1 < 0.75, weights = x1)
mf3
@

<<model.matrix-method>>=
model.matrix(terms(F3, lhs = 0, rhs = 2), data = mf3)
@

<<model.response-substitute>>=
Model.Response(F3, data = mf3, lhs = 1)
Model.Response(F3, data = mf3, lhs = 2)
@

<<model.foo-methods>>=
model.weights(mf3)
@


\subsubsection*{Further methods}

<<update-method>>=
update(F1, . ~ . - x1 | . + x1)
update(F1, . + y2 | y3 ~ .)
@

<<as.Formula-method>>=
as.Formula(y1 ~ x1, y2 ~ x2, ~ x3)
@


\section{Usage in Model Fitting Functions} \label{sec:usage}

(1)~process the call (could include weights and offset)

(2)~set up the model frame (using the \class{Formula} method)

(3)~extract (univariate) response and regressors

(4)~call \fct{lm.fit} twice to compute two-stage least squares estimator
and extract coefficients

<<ivcoef>>=
ivcoef <- function(formula, data, subset, na.action, ...)
{
  mf <- match.call(expand.dots = FALSE)
  m <- match(c("formula", "data", "subset", "na.action"), names(mf), 0)
  mf <- mf[c(1, m)]
  
  mf[[1]] <- as.name("model.frame")
  mf[[2]] <- as.call(list(as.name("Formula"), mf[[2]]))
  mf <- eval(mf, parent.frame())
  
  f <- Formula(formula)
  Y <- Model.Response(f, data = mf, lhs = 1)
  X <- model.matrix(f, data = mf, rhs = 1)
  Z <- model.matrix(f, data = mf, rhs = 2)

  XZ <- as.matrix(lm.fit(Z, X)$fitted.values)
  lm.fit(XZ, Y)$coefficients
}
@

<<ivcoef-example>>=
ivcoef(log(y1) ~ x1 | x2, data = dat)
@

Function \fct{ivreg} with inference in \pkg{AER} \citep{AER:Kleiber+Zeileis:2008}

\section{Summary} \label{sec:summary}

\bibliography{Formula}

\end{document}
